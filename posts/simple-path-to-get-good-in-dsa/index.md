<!--
.. title: Simple path to get good in DSA
.. slug: simple-path-to-get-good-in-dsa
.. date: 2024-03-02 16:54:23 UTC+05:30
.. tags: 
.. category: 
.. link: 
.. description: 
.. type: text
-->

Preparing to tackle Data Structures and Algorithms (DSA) effectively involves a dual approach, which I categorize as "Mathematics" and "Intuition". Much like mathematics, where one begins with learning theorems and formulas before solving problems, mastering DSA requires a solid foundation in popular data structures and algorithms followed by honing problem-solving intuition.

**Part 1: Mathematics**

Start by comprehensively understanding and committing to memory all essential algorithms in DSA. Progress through the following levels:

1. **Math + Array + String**
2. **Hashing (Hashset, HashMap) + Stack + Queue**
3. **Graph**
4. **Linked List + Binary Tree + BST + AVL + RB**
5. **Dynamic Programming**

Acquiring a deep understanding of each topic is paramount. Without ingraining these algorithms into memory, solving problems becomes significantly more challenging. It's akin to knowing what needs to be done but struggling to articulate it. Therefore, prioritize memorizing algorithms for each topic. Here's a breakdown of algorithms for each category:

- **Math:** LCM, GCD, Prime number detection, Sieve of Eratosthenes, principle of mutual exclusion, square root calculation, binary and ternary exponentiation, bit arithmetic, permutation, combination, factorial, time complexity.
- **Array:** Linear search, binary search, sorting algorithms, heap, two pointers, three pointers.
- **String:** String manipulation methods (e.g., indexOf, replace, substring), string-based algorithms (e.g., Rabin-Karp, hashing).
- **Hashing:** Hashset, Hashmap implementation in the chosen programming language.
- **Graph:** BFS, DFS, Shortest path, longest path, Dijkstra's algorithm, Tarjan's algorithm, Kosaraju's algorithm.
- **LinkedList, Binary Tree (BT), Binary Search Tree (BST), AVL Tree, Red-Black Tree (RB)**
- **Dynamic Programming:** Classical dynamic programming problems.

The list is not complete but you can get exhaustive list of algorithms anywhere on the internet. 

**Part 2: Intuition**

Upon completing each level, immerse yourself in problem-solving. These problems demand more than just applying memorized algorithms; they require a deep understanding of the problem and the ability to adapt standard algorithms to solve specific scenarios. Consider the memorized algorithms as templates that guide your problem-solving approach.

Only tackle problems related to each level after memorizing all relevant algorithms. To access such problems, utilize platforms like LeetCode and filter by tags corresponding to each topic.

**One crucial tip:** Avoid fixating on the number of problems solved. While seeing the count rise can be momentarily gratifying, it can also impede progress. Instead, focus on intrinsic motivation and improvement in problem-solving intuition. Think of it as long-term fitness training; it's not about how many drills you perform but how effectively you perform in the actual game.

By adopting this comprehensive approach, you'll not only master DSA but also develop robust problem-solving skills essential for real-world applications. Remember, it's a journey of continual learning and refinement rather than a race to accumulate problem-solving streaks.

That is all one has to do to get good at DSA. Nothing more and nothing less. Getting good at DSA is not essential for doing your job i.e. software engineering but it is a benchmark over which you will be hired and you will hire others. In the beginning of our job we will find ourselves solving DSA problems for getting one and in the latter we will asking DSA questions for giving one.

