<!--
.. title: Simple path to get good in DSA
.. slug: simple-path-to-get-good-in-dsa
.. date: 2024-03-02 16:54:23 UTC+05:30
.. tags: programming, career
.. category: Data Structures Algorithms
.. link:
.. description: Simple path to get good at solving Data Structure and Algorithm problems.
.. type: text
-->

Preparing to tackle Data Structures and Algorithms (DSA) effectively involves a dual approach, which I categorize as "Mathematics" and "Intuition". Much like mathematics, where one begins with learning theorems and formulas before solving problems, mastering DSA requires a solid foundation in popular data structures and algorithms followed by honing problem-solving intuition.

### Part 1: Mathematics

Start by comprehensively understanding and committing to memory all essential algorithms in DSA. Progress through the following levels:

1. **Math + Array + String**
2. **Hashing (Hashset, HashMap) + Stack + Queue**
3. **Graph**
4. **Linked List + Binary Tree + BST + AVL + RB**
5. **Dynamic Programming**

Acquiring a deep understanding of each topic is paramount. Without ingraining these algorithms into memory, solving problems becomes significantly more challenging. It's akin to knowing what needs to be done but struggling to articulate it. Therefore, prioritize memorizing algorithms for each topic. Here's a breakdown of algorithms for each category:

**Math:**

- LCM
- GCD
- Is Prime
- Sieve of Eratosthenes
- Binary Exponentiation
- Modular Exponentiation
- Karatsuba
- Fermat's little theorem
- Bit arithematic
- Permutation
- Combination

**Array:**

- Linear Search
- Binary Search
- Bubble Sort
- Selection Sort
- Insertion Sort
- Merge Sort
- Quick Sort
- Counting Sort
- Radix Sort
- Heap Sort
- Shell Sort
- Bucket Sort
- Cycle Sort
- Two Pointer
- Three Pointer

**String:**

- All String manipulation methods in programming language of choice.
- Rabin-Karp
- KMP
- Boyre Moore
- Trie
- Levenshtein Distance
- Longest Common Subsequence

**Hashing:**

- Hashset
- Hashmaps
- Using arrays as maps

**Stacks & Queues:**

- Know-How

**Graph:**

- BFS
- DFS
- Dijkstra's Algorithm
- Bellman-Ford Algorithm
- Floyd-Warshall Algorithm
- Prim's Algorithm
- Kruskal's Algorithm
- Topological Sorting
- Tarjan's Algorithm
- Kosaraju's Algorithm
- Bipartite Checking
- Articulation Points
- Eulerian Path and Circuit
- Hamiltonian Path and Circuit
- Minimum Cut

**Linked List, Binary Tree, Binary Search Tree, AVL Tree, RB Tree:**

- Know-How

**Dynamic Programming(Classical problems):**

- Fibonacci Series
- Longest Common Subsequence
- Longest Incresing Subsequence
- Knapsack Problem
- Matrix Chain Multiplication
- Edit Distance
- Coin Change Problem
- Subset Sum Problem
- Partition Equal Subset Sum
- 0/1 Knapsack Problem
- Maximum Subarray Sum
- Rod Cutting Problem
- Coin Row Problem

The list is not complete but you can get exhaustive list of algorithms anywhere on the internet.

### Part 2: Intuition

Upon completing each level, immerse yourself in problem-solving. These problems demand more than just applying memorized algorithms; they require a deep understanding of the problem and the ability to adapt standard algorithms to solve specific scenarios. Consider the memorized algorithms as templates that guide your problem-solving approach.

Only tackle problems related to each level after memorizing all relevant algorithms. To access such problems, utilize platforms like LeetCode and filter by tags corresponding to each topic.

**One crucial tip:** Avoid fixating on the number of problems solved. While seeing the count rise can be momentarily gratifying, it can also impede progress. Instead, focus on intrinsic motivation and improvement in problem-solving intuition. Think of it as long-term fitness training; it's not about how many drills you perform but how effectively you perform in the actual game.

By adopting this comprehensive approach, you'll not only master DSA but also develop robust problem-solving skills essential for real-world applications. Remember, it's a journey of continual learning and refinement rather than a race to accumulate problem-solving streaks.

That is all one has to do to get good at DSA. Nothing more and nothing less. Getting good at DSA is not essential for doing your job i.e. software engineering but it is a benchmark over which you will be hired and you will hire others. In the beginning of our job we will find ourselves solving DSA problems for getting one and in the latter we will asking DSA questions for giving one.
